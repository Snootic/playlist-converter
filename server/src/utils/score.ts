import { ScoreDetails, SpotifyArtist, SpotifyTrack, VideoMetadata } from "@types";
import { normalizeText } from "@/utils/textParser";

function scoreDuration(youtubeVideo: VideoMetadata, spotifyTrack: SpotifyTrack): number {
  const durationDiff = Math.abs(youtubeVideo.seconds - Math.round(spotifyTrack.duration_ms) / 1000);
  if (Math.floor(durationDiff) <= 5) return 2;
  if (Math.floor(durationDiff) <= 20) return 0;
  return -2;
}

function scoreKeywords(text: string, keywords: Set<string>, weight: number = 1): number {
  return Array.from(keywords).reduce((score, keyword) => {
    if (text.includes(keyword)) score += weight;
    return score;
  }, 0);
}
  
function scoreNegativeKeywords(text: string, keywords: Set<string>, weight: number = -2): number {
  return Array.from(keywords).reduce((score, keyword) => {
    if (text.includes(keyword)) score += weight;
    return score;
  }, 0);
}

export default function score(spotifyTrack: SpotifyTrack, videoMetadata: VideoMetadata): ScoreDetails | null {
  let scoreDetails: ScoreDetails = {
    duration: 0,
    positiveKeywords: 0,
    negativeKeywords: 0,
    negativeNamewords: 0,
    authorMatch: 0,
    autoGenerated: 0,
    bonus: 0
  };

  const trackName = normalizeText(spotifyTrack.name);
  const trackArtists = spotifyTrack.artists.map((artist: SpotifyArtist) => normalizeText(artist.name));
  const trackAlbum = normalizeText(spotifyTrack.album.name);

  const positiveKeywords = new Set<string>([trackName, ...trackArtists, trackAlbum, "official"]);
  const negativeNamewords = new Set<string>(["instrumental", "cover", "remix", "live", "acoustic", "reupload", "playtrough"]);
  const negativeKeywords = new Set<string>(["tutorial", "how to", "fair use", "copyright", "subs", "sub", "fan", "disclaimer"]);

  const videoTitle = normalizeText(videoMetadata.title);
  const videoDescription = normalizeText(videoMetadata.description);

  if (Math.abs(videoMetadata.seconds - Math.round(spotifyTrack.duration_ms) / 1000) >= 30) {
    return null;
  }

  scoreDetails.duration = scoreDuration(videoMetadata, spotifyTrack);

  scoreDetails.positiveKeywords += scoreKeywords(videoTitle, positiveKeywords, 2);
  scoreDetails.positiveKeywords += scoreKeywords(videoDescription, positiveKeywords, 1);

  scoreDetails.negativeKeywords += scoreNegativeKeywords(videoTitle, negativeKeywords, -2);
  scoreDetails.negativeKeywords += scoreNegativeKeywords(videoDescription, negativeKeywords, -1);

  for (const keyword of negativeNamewords) {
    if (videoTitle.includes(keyword) && !trackName.includes(keyword) || !videoTitle.includes(keyword) && trackName.includes(keyword)) {
    scoreDetails.negativeNamewords -= 3;
    } else if (videoTitle.includes(keyword) && trackName.includes(keyword)) {
    scoreDetails.negativeNamewords += 2;
    }
  }

  for (const artist of trackArtists) {
    if (normalizeText(videoMetadata.author.name).includes(artist)) {
    scoreDetails.authorMatch += 2;
    }
    if (videoDescription.includes("autogenerated by youtube") && videoDescription.includes(artist)) {
    scoreDetails.authorMatch++;
    }
  }

  if (videoDescription.includes("autogenerated by youtube") && videoDescription.includes(`${trackName} Â·`)) {
    scoreDetails.autoGenerated++;
  }
  if (videoDescription.includes("autogenerated by youtube") && videoDescription.includes(trackAlbum)) {
    scoreDetails.autoGenerated++;
  }

  return scoreDetails;
}